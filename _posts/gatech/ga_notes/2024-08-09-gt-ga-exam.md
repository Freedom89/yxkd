---
title: CS6515 OMSCS - Graduate Algorithms DP DC Prep
date: 2024-08-15 0000:00:00 +0800
categories: [Courses, Gatech, Notes]
tags: [courses, omscs, gatech_notes]     # TAG names should always be lowercase
math: true
toc: true
mermaid: true
hidden: true
---

## Dynamic Programming

For dynamic programming, your solution needs to have 4 parts:

* Subproblem definition
* Recurrence relation
   * **STATE YOUR BASE CASES!**
* Psuedocode
* Complexity 

> For subproblem definition, there is a "weak" version and the "strong" inclusion.
> What the strong inclusion means is you **include** the i-th term in your recurrence. So, your T[i] must include a[i] **no matter what**.
>
> If you only "consider" it, then, use the words `up to` and not `include`.
{: .prompt-info }

There are a few cases when the **strong** definition is required, especially when you need to consider a **restart** in your recurrence such as LIS. Sometimes it is easier to use a strong definition to solve a problem.

In terms of dynamic programming,

> Only prefix and window dynamic programming problems are valid, there is no suffix problem.
> Only Floyd Warshall and Chain Matrix Multiply (CMM) are $O(n^3)$.
{: .prompt-tip }

* I find it useful to identify if it is a prefix problem, or a window problem $x_i,...,x_j$. If it is a window problem, then it should be a CMM.
* Otherwise, if it is a lookback problem, is the lookback window fixed?
  * For example, for a given $j$, do we only look back $j-1$, $j-2$? If so, this is likely to be a $O(n)$ problem
    * If you look back to i-1, i-2 for instance, then it is likely that you need two base cases, one for T[1], T[2]. You could also use T[0], T[-1] if you prefer as long as the solution works!
  * If we always need to look back from the start, then, it is likely that this is $O(n^2)$.
* Lastly, **backtracking** is not covered in this notes! 

### Longest Increasing Subsequence (LIS)

`Problem statement`

Given a following sequence, find the length of the longest increasing subsequence. For example, given Input: 5, 7, 4, -3, 9, 1, 10, 4, 5, 8, 9, 3, the longest subsequence will be -3, 1, 4, 5, 8, 9, and the answer will be 6.

`Intuition`

Two observations:
* The lookback is always to the start
* Although the lookback starting point can change, for example:
  * 5 4 -3 -2 -1 0 1 2 3, then at `-3` is where we should start
  * So, this tells us we should use the `strong` definition.

`Subproblem`

Let T[i] be the longest increasing subsequence, including i.

`Recurrence relation`

```
T[i] = 1 + max{T[j] if x[i] > x[j] : where 1 <= j <= i-1} \\
        where 1 <= i <= n
```

`Psuedocode`

```
for i in range(1,n):
    T[i] = 1
    for j in range(1,i-1):
        if x[i] > x[j] and T[j] + 1 > T[i]:
            T[i] = T[j] + 1

return max(T[.])            
```

`Complexity`

Two inner for loops, hence $O(n^2)$.

### Longest Common Subsequence (LCS)

`Problem statement`

Given two sequences, $x_1,..,x_n$ and $y_1,...,y_m$, find the longest common subsequence. For example given X = BCDBCDA and Y = ABECBAB, then the longest subsequence is BCBA.

`Intuition`

Observations:
* When I add a new character in both of them, it either increases the score or does not.
* Since it may not increase the score (we choose to skip it), then we should use the weak definition.
* Since we are using the weak, then the score must be maximum of either i and j-1, or i-1 and j.

`Subproblem`

Let L[i,j] denote the longest common subsequence between x from 1 up to i, and y from 1 up to j.

`Recurrence relation`

Base case: 

```
L[i, j] = 0 where 0 <= i <= n
L[0, j] = 0 where 0 <= j <= m
```

Relation:

```
L[i,j] = 1 + L[i-1, j-1]  if x[i] == y[j]
    where 1 <= i <= n, 1<= j <= m 
L[i,j] = max(L[i-1, j], L[i, j-1]) if x[i] != y[j] 
    where 1 <= i <= n, 1<= j <= m 
```

`Psuedocode`

```
L[0, j] = 0 # add for loop
L[i, 0] = 0 # add for loop 
for i in range(1,n):
    for j in range(1,m):
        if x[i] == y[j]:
            L[i,j] = 1 + L[i-1, j-1]
        else:
            L[i,j] = max(L[i-1, j], L[i, j-1])
return L[n][m]
```

`Complexity`

Two inner loops, $O(nm)$


### Contiguous Subsequence Max Sum

`Problem statement`

A contiguous subsequence of a list S is a subsequence made up of consecutive elements of S. For instance, if S is 5, 15, −30, 10, −5, 40, 10, then 15, −30, 10 is a contiguous subsequence but 5, 15, 40 is not. Give a linear-time algorithm for the following task:

`Intuition`

* Again, this is similar to LIS we might need to restart the starting point (Observe the answer above is 10, -5, 40, 10). So, this tells us we should be using the **strong** definition.

`Subproblem`

Let T[i] be the max sum of the subsequence of x from 1, ..., i including i.

`Recurrence relation`

Base case: `T[0] = 0`

```
T[i] = x[i] + max(0, T[i-1]) where 1 <= i <= n
```

`Psuedocode`

```
T[0] = 0
for i in range(n):
    T[i] = x[i] + max(0, T[i-1])
return max(T[.])
```

`Complexity`

Only one for loop, $O(n)$.

### Knapsack

`Problem statement`

Given $n$ items with weights $w_1,w_2,..., w_n$ each with value $v_1,...,v_n$ and capacity $B$, we want to find the subset of objects S, such that we maximize values max($\sum_{i\in S} v_i$ ) but $\sum_{i \in S} w_i < B$..

`Intuition`

* This is a prefix problem, and, when you add a new item, either you can find a better solution, OR you cannot find a better solution.
* So this tells you that you can skip the i item, so, weak definition.
* If you do not include the ith item, then the best at i, is i-1.

Also, since this is knapsack, we also need to vary the weight B.

`Subproblem`

Let K(i, b) to be the optimal solution involving up to the first i items with capacity b. 

`Recurrence relation`

Base case: 

```
K(i, 0) = 0 where 1 <= i <= n
K(0, b) = 0 where 1 <= b <= B
```

Relation:

```
K(i,b) = max(
        v[i] + K(i-1, b - w[i]), 
        K(i-1,b)
        ) where 1 <= i <= n, w[i] <= b
```

`Psuedocode`

```
K(i,0) = 0 # add for loop
K(0, b) = 0 # add for loop

for i in range(1, n):
    for b in range(1,B):
        tmp1 = v[1] + K(i-1, b-w[i])
        tmp2 = K(i-1,b)
        K(i,w) = max(tmp1,tmp2)
return K(n,B)
```

`Complexity`

There is two loops, N, and W, so, $O(NB)$.

`Extra notes:`

* Knapsack is also known as a Pseudo-polynomial time problem because of B.

### Knapsack with repetitions

`Problem statement`

Same as above, but now you have unlimited items of each. 

`Intuition`

* Then this becomes simple, when you add a new item, either it can help you get a better score, or, it cannot!
* Problem definition should remain weak.

You can choose to modify the above approach and simplify use:

$$
K(i,b) = max(v_i + K(i-1, b-w_i), K(i-1,b))
$$

But there is an easier way:

* We can just remove the `K(i-1,b)` since we are no longer constraint on the items, so:

`Subproblem`

Let K(b) be the maximum value obtainable from weight 1 ... b up to B.

`Recurrence relation`

```
K(b) = max{v[i] + K(b - w[i])}
    where 1 <= i <= n, w[i] <= b
```

`Psuedocode`

```
for b in range(1,B)
    K[b] = 0
    for i in range(1,n):
        if w[i] < b and K[b] < v[i] + K[b-w[i]]:
            K[b] = v[i] + K[b-w[i]]
return K(B)
```

`Complexity`

Complexity does not change, and remains $O(nB)$.

### Chain Matrix Multiply 

`Problem statement`

`Intuition`

`Subproblem`

`Recurrence relation`

`Psuedocode`

`Complexity`

### Bellman-Ford

`Problem statement`

`Intuition`

`Subproblem`

`Recurrence relation`

`Psuedocode`

`Complexity`

### Floyd-Warshall 

`Problem statement`

`Intuition`

`Subproblem`

`Recurrence relation`

`Psuedocode`

`Complexity`

### Edit Distance

`Problem statement`

`Intuition`

`Subproblem`

`Recurrence relation`

`Psuedocode`

`Complexity`

## Divide and Conquer

For Divide and conquer, three sections are required:

* Algorithms.
  * You are allowed to modify Binary search, Merge sort, Fast Select, FFT.
  * If you make modification, it is not enough to state your modification, you need to state **how** you use your modification
  * **STATE YOUR BASE CASE!**
* Justification of correctness
  * Why does the algorithm work? Why did you make certain changes?
  * What is it about the problem size that allows your algorithm to be correct?
* Runtime analysis
  * Even if your modifications is trivial, **remember to state them!**.

### Master Theorem

$$
T(n) =
\begin{cases}
O(n^d), & \text{if } d > \log_b a \\
O(n^d \log n), & \text{if } d = \log_b a \\
O(n^{\log_b a}), & \text{if } d < \log_b a
\end{cases}
$$

For constants $a>0, b>1, d \geq 0$.

The recurrence relation under the Master Theorem is of the form:

$$
T(n) = aT\left(\frac{n}{b}\right) + O(n^d)
$$

### Fast Integer Multiply

### Linear-time median

### FFT